# 并发与并行的区别
![并发与并行图示](https://pic2.zhimg.com/80/v2-a825e6507f99e6240807e4b1bdc9a721_1440w.webp)

- 并发（concurrency）：指计算机似乎能在同一时刻做许多件不同的事情。在单核CPU的计算机上面，操作系统可以迅速切换这个处理器所运行的程序，<br>
  因此尽管同一时刻最多只有一个程序在运行，但这些程序能够交替地使用这个核心，从而造成一个假象，让人觉得它们好像真的在同时运行。<br>
- 并行（paralleslism）：计算机真的能够在同一时刻做很多件不同的事情。例如，若计算机配有多个CPU核心，那么它就真的可以同时执行多个程序。<br>
  每个CPU核心执行的都是自己的那个程序之中的指令，这些程序能够同时向前推进。<br>

**使用场景**
- 并发通常应用于 I/O 操作频繁的场景，比如你要从网站上下载多个文件，I/O 操作的时间可能会比 CPU 运行处理的时间长得多。
- 而并行则更多应用于 CPU heavy 的场景，比如Hadoop、Spark等的MapReduce中的并行计算，为了加快运行速度，一般会用多台机器、多个处理器来完成。

# 同步 和 异步 的概念
- 同步（Sync）：同步世界中，事件一次只发生一个。调用一个函数时，你的程序只能等待它完成，然后继续做下一件事情。
  类比晚上回来用洗衣机洗衣服，洗衣机要等10分钟，在这10分钟内，你就只能干等，等洗衣机洗完再干其它的事情。
- 异步（Async）：在异步世界中，多个事情可以同时发生。当启动一个操作或调用一个函数时，程序将会继续运行，你可以执行其他操作或调用其他函数，
  而不只是等待异步函数执行完成。一旦异步函数完成了工作，程序就可以访问异步函数的执行结果。类比晚上回来用洗衣机洗衣服，洗衣机要等10分钟，
  在这10分钟内，你可以洗澡、刷牙，等洗衣机洗完后，你可以接着把衣服晾起来。

# 多线程能加速吗？
*而Python中，假如使用的是CPython解释器，其实就跟真正的的“多线程”无缘了。*

**Python语言的标准实现叫做CPython，它分两步来运行Python程序。首先解析源代码文件，并将其编译成字节码（bytecode）。然后，CPython采用基于栈的解释器来运行字节码。这种字节码解释器在执行Python程序的过程中，必须确保相关的状态不受干扰，所以CPython会用一种叫做全局解释器锁（global interpreter lock， GIL）的机制来保证这一点。当解释器在运行线程A的字节码时，会先锁住自己的线程，阻止别的线程执行。**

**GIL实际上就是一个互斥锁（mutual-eclusion lock, mutex），用来防止CPython的状态在抢占式的多线程之中收到干扰，因为在这种环境下，一条线程有可能突然打断另一条线程抢占程序的控制权。如果这种抢占行为来得不是时候，那么解释器的状态（例如为垃圾回收工作而设立的引用计数等，举个例子，有两个 Python 线程同时引用了 a，就会造成引用计数的 race condition，引用计数可能最终只增加 1，这样就会造成内存被污染。因为第一个线程结束时，会把引用计数减少 1，这时可能达到条件释放内存，当第二个线程再试图访问 a 时，就找不到有效的内存了）就会操作破坏。所以，CPython要通过GIL组织这样的动作，以确保它自身以及它的那些C拓展模块能够正确执行每一条字节码指令。**

**线程由于不同的编程语言实现的方式不同，也有差别，对于C语言而言，线程也可以通过调度将多个线程分配到多个CPU的核上，而对于Python语言，由于Python在实现过程中（Cpython）人为的引入了GIL（全局解释器锁），使得Python的多线程程序在运行的时候，同一时刻只能运行一个线程，且同一时刻只能占用CPU的一个核，造成了一核有难、八核围观的窘境**

# linux 进程 和 windows进程的区别
*在Linux内核中，描述一个进程主要是task_struct，一个称为进程描述符的数据结构。这个数据结构很庞大，包含了内核管理一个进程所需的所有信息，描述了一个正在执行的进程，包括进程ID，它打开的文件，进程的地址空间，挂起的信号，进程的状态等等其他信息。*

*Linux的线程机制和Windows等其他操作系统的很不一样，Linux中没有为线程设置专门的数据结构，也没有专门的线程调度算法，在Linux内核看来，线程就是一个进程，只是一个和其他进程共享资源的特殊进程而已。*

*在Linux中，创建线程时，和创建普通的进程类似，每个线程都拥有自个的进程描述符task_struct，只是在调用clone()的时候需要传递一些参数标志来指明共享的资源。如图1所示。*

![linux中进程和线程](https://img-blog.csdn.net/20160331215845896)


*在windows等其他操作系统中，进程拥有一个进程描述符，描述一些地址空间和打开的文件等共享资源，进程中包含指向不同线程的指针，这些线程没有进程描述符，只描述一些少量的独有的资源，因此很轻量。同时这些线程共享进程的资源。如图2所示。*

![window中的进程和线程](https://img-blog.csdn.net/20160331215859380)


# 协程
看起来A、B的执行有点像多线程，但协程的特点在于是一个线程执行，那和多线程比，协程有何优势？

最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。

第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。

# 查看核个数
*查看物理CPU个数*
cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l
*查看每个物理CPU中core的个数(即核数)*
cat /proc/cpuinfo| grep "cpu cores"| uniq
*查看逻辑CPU的个数*
cat /proc/cpuinfo| grep "processor"| wc -l